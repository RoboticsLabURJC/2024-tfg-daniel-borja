---
title: "Semana 19. Implementación de la densificación utilizando diferentes algoritmos de interpolación 2"
categories:
  - Weblog
tags:
  - Lidar
  - Visor 3d
  - Python
  - Goose 
  - Rellis 3d
  - CARLA
  - Densificación
  - Auto-interpolación
  - 1-NN
  - 2-NN
  - IDW

---

## 1-NN
He realizado modificaciones en el algoritmo 1-NN de manera que la posición del punto que se genera esté situado en el vector que une el punto seleccionado y su vecino mas cercano, siguiendo la fórmula ```C = A + α(B-A)```. Siendo ```C``` el punto generado, ```A``` el punto original seleccionado , ```B```su vecino mas cercano y ```α``` un factor aleatorio que sige una distribución gaussiana.
```python
      # Interpolar entre el punto original y el vecino aplicando C = A + α(B - A)
      displacement = np.random.normal(loc=0.5, scale=0.1)  # Media 0.5 desviación 0.1
      interpolated_point = point + displacement * (neighbor_point - point)
```

Aumento de la densidad con 1-NN:

<figure class="align-center" style="max-width: 100%">
  <img src="{{ site.url }}{{ site.baseurl }}/assets/images/1NN_v2.png" alt="1NN-v2">
</figure>

## 2-NN
De la misma manera que el caso anterior he implementado una densificación utilizando 2-NN, en este caso se tendran en cuenta los valores de los dos vecinos más cercanos. Las coordenadas del punto generado siguen la fórmula ```D = A + α(B-C) + β(C-A)```.   Donde ```D``` el punto generado, ```A``` el punto original seleccionado , ```B```y ```C``` sus vecinos mas cercanos y ```α``` y ```β``` dos factores aleatorios que siguen una distribución gaussiana.

```python
      # Interpolar entre el punto original y los 2 vecino seleccionado aplicando D = A + α(B - A) + β(C - A)
      alpha = np.random.normal(loc=0.5, scale=0.1)  # Media 0.5 desviación 0.1
      beta = np.random.normal(loc=0.5, scale=0.1)  # Media 0.5 desviación 0.1
      interpolated_point = point + alpha * (neighbor1 - point) + beta * (neighbor2 - point)
```

Aumento de la densidad con 2-NN:

<figure class="align-center" style="max-width: 100%">
  <img src="{{ site.url }}{{ site.baseurl }}/assets/images/2NN.png" alt="2-NN">
</figure>

## IDW
Para solucionar el problema con la interpolacion de los valores de r, implemento el algoritmo de Interpolación Ponderada por Distancia Inversa o IDW (del ingles Inverse Distance Weighted). De esta manera se dá más peso a los puntos más cercaos y se reduce el peso de los más alejados.
La posicion de los puntos seguirá decidiendose utilizando 1-NN o 2-NN y la IDW se utilizará para los valores interpolados de r, de tal forma que se cumpla:

### Para 1-NN

$r'=\frac{\frac{1}{d_{A}}*r_{A}+\frac{1}{d_{B}}*r_{B}}{\frac{1}{d_{A}}+\frac{1}{d_{B}}}$ 

Donde r' es el valor de r interpolado, $d_{A}$ y $d_{B}$ son las distancias entre el punto generado y los puntos que se han tomado de la nube original, $r_{A}$ y $r_{B}$ son los valores de r de los puntos utilizados de la nube original.

Se a añadido al script para la densificacion usando 1NN el calculo de las distancias y la fórmula de la interpolación.

```python
      # Calcular las distancias d_A y d_B
      d_A = np.linalg.norm(interpolated_point - point)  # Distancia al punto original
      d_B = np.linalg.norm(interpolated_point - neighbor_point)  # Distancia al vecino
        
      # Aplicar la fórmula de interpolación para la remisión
      r_A = remissions[index]  # Remisión del punto original
      r_B = remissions[indices[0][1]]  # Remisión del vecino

      # Fórmula de interpolación de la remisión
      interpolated_remission = ( (1/d_A) * r_A + (1/d_B) * r_B ) / ( (1/d_A) + (1/d_B) )
```

Aumento de la densidad usando 1-NN y IDW:

<figure class="align-center" style="max-width: 100%">
  <img src="{{ site.url }}{{ site.baseurl }}/assets/images/IDW_1NN.png" alt="IDW_1NN">
</figure>
 
### Para 2-NN
En el caso de utilizar los dos vecinos más cercanos, a la fórmula de la interpolación de r hay que añadir la distancia del punto interpolado al segundo vecino $d_{C}$ y el valor de intensidad del punto C $r_{C}$.

$r'=\frac{\frac{1}{d_{A}}*r_{A}+\frac{1}{d_{B}}*r_{B}+\frac{1}{d_{C}}*r_{C}}{\frac{1}{d_{A}}+\frac{1}{d_{B}}+\frac{1}{d_{C}}}$

Donde $d_{C}$ es la distancia entre el punto interpolado y el tercer vecino, $r_{C}$ el valor de la intensidad del tercer vecino. Se calcula por tanto tambine la distancia al tercer punto para poder aplicar la interpolación.

```python
      # Interpolar entre el punto original y el vecino seleccionado
      alpha = np.random.normal(loc=0.5, scale=0.1)  # Media 0.5 desviación 0.1
      beta = np.random.normal(loc=0.5, scale=0.1)  # Media 0.5 desviación 0.1
        
      # Aplicar D = A + α(B - A) + β(C - A)
      interpolated_point = point + alpha * (neighbor1 - point) + beta * (neighbor2 - point)
        
      # Calcular las distancias d_A, d_B y d_C
      d_A = np.linalg.norm(interpolated_point - point)  # Distancia al punto original
      d_B = np.linalg.norm(interpolated_point - neighbor1)  # Distancia al primer vecino
      d_C = np.linalg.norm(interpolated_point - neighbor2)  # Distancia al segundo vecino

      # Aplicar la fórmula de interpolación para la remisión
      r_A = remissions[index]  # Remisión del punto original
      r_B = remissions[indices[0][1]]  # Remisión del primer vecino
      r_C = remissions[indices[0][2]]  # Remisión del segundo vecino

      # Fórmula de interpolación de la remisión
      interpolated_remission = ( (1/d_A) * r_A + (1/d_B) * r_B + (1/d_C) * r_C ) / ( (1/d_A) + (1/d_B) + (1/d_C) )
```
Aumento de la densidad usando 2-NN y IDW:

<figure class="align-center" style="max-width: 100%">
  <img src="{{ site.url }}{{ site.baseurl }}/assets/images/IDW_2NN.png" alt="IDW_2NN">
</figure>